# handlers/admin/broadcasts_wizard.py
# –ê–¥–º–∏–Ω: ¬´–æ–¥–Ω–æ –æ–∫–Ω–æ¬ª –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏ ‚Äî /post. –¢–µ–∫—Å—Ç + –≤–ª–æ–∂–µ–Ω–∏—è (file_id), –±–µ–∑ —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤.
# –®–∞–≥–∏: –ö–æ–Ω—Ç–µ–Ω—Ç ‚Üí –ù–∞–∑–≤–∞–Ω–∏–µ ‚Üí –¢–∏–ø ‚Üí –ê—É–¥–∏—Ç–æ—Ä–∏—è ‚Üí –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ (–ú–°–ö) ‚Üí –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ.

from __future__ import annotations

from typing import Any, Dict, List, Optional, Union
from html import escape as _html_escape
from datetime import datetime
from zoneinfo import ZoneInfo

import logging
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery, ContentType
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from services.local_scheduler import schedule_broadcast_send

# –í–ê–ñ–ù–û: –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –∏–º–ø–æ—Ä—Ç –∫–ª–∏–µ–Ω—Ç–∞
from services.db_api import db_api_client

log = logging.getLogger(__name__)
router = Router(name="admin_broadcasts_wizard")

MSK = ZoneInfo("Europe/Moscow")


class PostWizard(StatesGroup):
    collecting = State()
    title_wait = State()
    choose_kind = State()
    choose_audience = State()
    audience_ids_wait = State()
    audience_sql_wait = State()
    choose_schedule = State()
    confirm = State()


# ---------- helpers ----------

def _kb_kinds() -> InlineKeyboardBuilder:
    kb = InlineKeyboardBuilder()
    kb.button(text="üì∞ –ù–æ–≤–æ—Å—Ç–∏", callback_data="kind:news")
    kb.button(text="üìÖ –í—Å—Ç—Ä–µ—á–∏", callback_data="kind:meetings")
    kb.button(text="‚ö°Ô∏è –í–∞–∂–Ω—ã–µ –ø–æ—Å–ª–∞–Ω–∏—è", callback_data="kind:important")
    kb.button(text="üö´ –û—Ç–º–µ–Ω–∞", callback_data="cancel")
    kb.adjust(1)
    return kb

def _kb_audience() -> InlineKeyboardBuilder:
    kb = InlineKeyboardBuilder()
    kb.button(text="üë• –í—Å–µ (ALL)", callback_data="aud:all")
    kb.button(text="üßæ IDs –≤—Ä—É—á–Ω—É—é", callback_data="aud:ids")
    kb.button(text="üß† SQL-–≤—ã–±–æ—Ä–∫–∞", callback_data="aud:sql")
    kb.button(text="üîô –ù–∞–∑–∞–¥ (—Ç–∏–ø)", callback_data="back:kind")
    kb.button(text="üö´ –û—Ç–º–µ–Ω–∞", callback_data="cancel")
    kb.adjust(1)
    return kb

def _kb_schedule() -> InlineKeyboardBuilder:
    kb = InlineKeyboardBuilder()
    kb.button(text="üöÄ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–µ–π—á–∞—Å", callback_data="sch:now")
    kb.button(text="üóì –í–≤–µ—Å—Ç–∏ –¥–∞—Ç—É/–≤—Ä–µ–º—è (–ú–°–ö)", callback_data="sch:manual")
    kb.button(text="üîô –ù–∞–∑–∞–¥ (–∞—É–¥–∏—Ç–æ—Ä–∏—è)", callback_data="back:aud")
    kb.button(text="üö´ –û—Ç–º–µ–Ω–∞", callback_data="cancel")
    kb.adjust(1)
    return kb

def _kb_confirm() -> InlineKeyboardBuilder:
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", callback_data="post:confirm")
    kb.button(text="üîô –ù–∞–∑–∞–¥ (—Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ)", callback_data="back:sch")
    kb.button(text="üö´ –û—Ç–º–µ–Ω–∞", callback_data="cancel")
    kb.adjust(1)
    return kb

def _normalize_ids(text: str) -> List[int]:
    out: List[int] = []
    seen = set()
    for chunk in (text or "").replace(",", " ").split():
        if chunk.isdigit():
            v = int(chunk)
            if v not in seen:
                seen.add(v)
                out.append(v)
    return out

async def _audience_preview_text(target: Dict[str, Any]) -> str:
    try:
        prev = await db_api_client.audience_preview(target, limit=10000)
        total = prev.get("total", 0)
        sample = prev.get("sample") or []
        sample_txt = ", ".join(map(str, sample[:10])) if sample else ""
        tail = f"\n–ü—Ä–∏–º–µ—Ä ID: <code>{sample_txt}</code>" if sample_txt else ""
        return f"üë§ –í—Å–µ–≥–æ –≤ –∞—É–¥–∏—Ç–æ—Ä–∏–∏: <b>{total}</b>{tail}"
    except Exception as e:
        log.exception("audience_preview error: %s", e)
        return "‚ö†Ô∏è –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –∞—É–¥–∏—Ç–æ—Ä–∏–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω."

def _parse_dt_msk(s: str) -> Optional[datetime]:
    s = (s or "").strip()
    for fmt in ("%Y-%m-%d %H:%M", "%d.%m.%Y %H:%M"):
        try:
            naive = datetime.strptime(s, fmt)
            return naive.replace(tzinfo=MSK)
        except ValueError:
            continue
    return None

def _make_media_items(collected: Dict[str, Any]) -> List[Dict[str, Any]]:
    items: List[Dict[str, Any]] = []
    if collected.get("text_html"):
        items.append({"type": "html", "payload": {"html": collected["text_html"]}, "position": 0})
    for it in collected.get("single_media", []):
        payload = {"file_id": it["file_id"]}
        if it.get("caption_html"):
            payload["caption_html"] = it["caption_html"]
        items.append({"type": it["type"], "payload": payload, "position": len(items)})
    if collected.get("album"):
        items.append({"type": "album", "payload": {"items": collected["album"]}, "position": len(items)})
    return items


# ---------- /post ----------

@router.message(Command("post"))
async def cmd_post(message: Message, state: FSMContext):
    await state.clear()
    await state.update_data(
        collected={"text_html": None, "single_media": [], "album": None},
        title=None,
        kind=None,
        target=None,
        schedule={"mode": None, "at": None},
    )
    await state.set_state(PostWizard.collecting)
    await message.answer(
        "–°–æ–±–∏—Ä–∞–µ–º —Ä–∞—Å—Å—ã–ª–∫—É.\n"
        "‚Äî –ü—Ä–∏—à–ª–∏ <b>—Ç–µ–∫—Å—Ç</b> –∏/–∏–ª–∏ <b>–º–µ–¥–∏–∞</b> (–º–æ–∂–Ω–æ –∞–ª—å–±–æ–º –¥–æ 10).\n"
        "‚Äî –ö–æ–≥–¥–∞ –∑–∞–∫–æ–Ω—á–∏—à—å ‚Äî –æ—Ç–ø—Ä–∞–≤—å /done\n\n"
        "–§–∞–π–ª—ã —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –ø–æ <code>file_id</code>, –ø–æ–¥–ø–∏—Å–∏ ‚Äî –∫–∞–∫ HTML."
    )

@router.message(PostWizard.collecting, Command("done"))
async def collecting_done(message: Message, state: FSMContext):
    data = await state.get_data()
    c = data["collected"]
    if not (c.get("text_html") or c.get("single_media") or c.get("album")):
        await message.answer("–ü–æ–∫–∞ –ø—É—Å—Ç–æ. –î–æ–±–∞–≤—å —Ç–µ–∫—Å—Ç –∏–ª–∏ –º–µ–¥–∏–∞, –∑–∞—Ç–µ–º /done")
        return
    await state.set_state(PostWizard.title_wait)
    await message.answer("–í–≤–µ–¥–∏ <b>–Ω–∞–∑–≤–∞–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∏</b> (–∫–æ—Ä–æ—Ç–∫–æ).")

@router.message(PostWizard.title_wait, F.content_type == ContentType.TEXT)
async def title_input(message: Message, state: FSMContext):
    title = (message.text or "").strip()
    if not title:
        await message.answer("–ù–∞–∑–≤–∞–Ω–∏–µ –ø—É—Å—Ç–æ–µ. –í–≤–µ–¥–∏ –µ—â—ë —Ä–∞–∑.")
        return
    await state.update_data(title=title)
    await state.set_state(PostWizard.choose_kind)
    await message.answer("–í—ã–±–µ—Ä–∏ <b>—Ç–∏–ø —Ä–∞—Å—Å—ã–ª–∫–∏</b>:", reply_markup=_kb_kinds().as_markup())

@router.callback_query(PostWizard.choose_kind, F.data.startswith("kind:"))
async def kind_pick(cb: CallbackQuery, state: FSMContext):
    kind = cb.data.split(":", 1)[1]  # news/meetings/important
    await state.update_data(kind=kind)
    await state.set_state(PostWizard.choose_audience)
    await cb.message.edit_text("–í—ã–±–µ—Ä–∏ –∞—É–¥–∏—Ç–æ—Ä–∏—é:", reply_markup=_kb_audience().as_markup())

@router.callback_query(F.data == "back:kind")
async def back_to_kind(cb: CallbackQuery, state: FSMContext):
    await state.set_state(PostWizard.choose_kind)
    await cb.message.edit_text("–í—ã–±–µ—Ä–∏ <b>—Ç–∏–ø —Ä–∞—Å—Å—ã–ª–∫–∏</b>:", reply_markup=_kb_kinds().as_markup())

@router.callback_query(F.data == "cancel")
async def post_cancel(cb: CallbackQuery, state: FSMContext):
    await state.clear()
    await cb.message.edit_text("–û—Ç–º–µ–Ω–µ–Ω–æ.")


# ---- –∞—É–¥–∏—Ç–æ—Ä–∏—è ----

@router.callback_query(PostWizard.choose_audience, F.data == "aud:all")
async def aud_all(cb: CallbackQuery, state: FSMContext):
    target = {"type": "sql", "sql": "SELECT id AS user_id FROM users"}
    await state.update_data(target=target)
    prev = await _audience_preview_text(target)
    await state.set_state(PostWizard.choose_schedule)
    await cb.message.edit_text(f"üéØ –ê—É–¥–∏—Ç–æ—Ä–∏—è: <b>–í—Å–µ</b>\n{prev}\n\n–¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ:", reply_markup=_kb_schedule().as_markup())

@router.callback_query(PostWizard.choose_audience, F.data == "aud:ids")
async def aud_ids(cb: CallbackQuery, state: FSMContext):
    await state.set_state(PostWizard.audience_ids_wait)
    await cb.message.edit_text("–ü—Ä–∏—à–ª–∏ —Å–ø–∏—Å–æ–∫ <b>user_id</b> —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª/–ø–µ—Ä–µ–Ω–æ—Å —Å—Ç—Ä–æ–∫–∏.\n–ü—Ä–∏–º–µ—Ä: <code>123 456 789</code>")

@router.message(PostWizard.audience_ids_wait)
async def aud_ids_input(message: Message, state: FSMContext):
    ids = _normalize_ids(message.text or "")
    if not ids:
        await message.answer("–ù–µ –≤–∏–∂—É —á–∏—Å–µ–ª. –ü—Ä–∏—à–ª–∏ –µ—â—ë —Ä–∞–∑.")
        return
    target = {"type": "ids", "user_ids": ids}
    await state.update_data(target=target)
    prev = await _audience_preview_text(target)
    await state.set_state(PostWizard.choose_schedule)
    await message.answer(f"üéØ –ê—É–¥–∏—Ç–æ—Ä–∏—è: <b>{len(ids)} ID</b>\n{prev}\n\n–¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ:", reply_markup=_kb_schedule().as_markup())

@router.callback_query(PostWizard.choose_audience, F.data == "aud:sql")
async def aud_sql(cb: CallbackQuery, state: FSMContext):
    await state.set_state(PostWizard.audience_sql_wait)
    await cb.message.edit_text(
        "–ü—Ä–∏—à–ª–∏ <b>SELECT</b>, –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∏–π —Å—Ç–æ–ª–±–µ—Ü <code>user_id</code>.\n"
        "–ü—Ä–∏–º–µ—Ä: <code>SELECT id AS user_id FROM users WHERE ...</code>\n"
        "–ë–µ–ª—ã–π —Å–ø–∏—Å–æ–∫: <code>users, user_memberships, user_subscriptions, chats</code>"
    )

@router.message(PostWizard.audience_sql_wait)
async def aud_sql_input(message: Message, state: FSMContext):
    sql = (message.text or "").strip()
    if not sql.lower().startswith("select"):
        await message.answer("–¢–æ–ª—å–∫–æ SELECT-–∑–∞–ø—Ä–æ—Å—ã. –ü—Ä–∏—à–ª–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π SQL.")
        return
    target = {"type": "sql", "sql": sql}
    await state.update_data(target=target)
    prev = await _audience_preview_text(target)
    await state.set_state(PostWizard.choose_schedule)
    await message.answer(f"üéØ –ê—É–¥–∏—Ç–æ—Ä–∏—è: <b>SQL</b>\n<code>{_html_escape(sql)}</code>\n\n{prev}\n\n–¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ:", reply_markup=_kb_schedule().as_markup())

@router.callback_query(F.data == "back:aud")
async def back_audience(cb: CallbackQuery, state: FSMContext):
    await state.set_state(PostWizard.choose_audience)
    await cb.message.edit_text("–í—ã–±–µ—Ä–∏ –∞—É–¥–∏—Ç–æ—Ä–∏—é:", reply_markup=_kb_audience().as_markup())


# ---- —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ ----

@router.callback_query(PostWizard.choose_schedule, F.data == "sch:now")
async def sch_now(cb: CallbackQuery, state: FSMContext):
    await state.update_data(schedule={"mode": "now", "at": None})
    await _show_confirm(cb, state)

@router.callback_query(PostWizard.choose_schedule, F.data == "sch:manual")
async def sch_manual(cb: CallbackQuery, state: FSMContext):
    await cb.message.edit_text(
        "–í–≤–µ–¥–∏ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è <b>–≤ –ú–°–ö</b> –≤ –æ–¥–Ω–æ–º –∏–∑ —Ñ–æ—Ä–º–∞—Ç–æ–≤:\n"
        "‚Ä¢ <code>YYYY-MM-DD HH:MM</code>\n"
        "‚Ä¢ <code>DD.MM.YYYY HH:MM</code>\n\n"
        "–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å: Europe/Moscow."
    )

@router.message(PostWizard.choose_schedule)
async def sch_manual_input(message: Message, state: FSMContext):
    dt = _parse_dt_msk(message.text or "")
    if not dt:
        await message.answer("–ù–µ –ø–æ–Ω—è–ª –¥–∞—Ç—É/–≤—Ä–µ–º—è. –ü—Ä–∏–º–µ—Ä: <code>2025-08-23 20:30</code> (–ú–°–ö)")
        return
    await state.update_data(schedule={"mode": "at", "at": dt})
    await _show_confirm(message, state)

@router.callback_query(F.data == "back:sch")
async def back_schedule(cb: CallbackQuery, state: FSMContext):
    await state.set_state(PostWizard.choose_schedule)
    await cb.message.edit_text("–í—ã–±–µ—Ä–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ:", reply_markup=_kb_schedule().as_markup())


# ---- –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∏ —Ñ–∏–Ω–∞–ª ----

async def _show_confirm(evt: Union[Message, CallbackQuery], state: FSMContext):
    data = await state.get_data()
    title = data.get("title") or "‚Äî"
    kind = data.get("kind") or "‚Äî"
    target = data.get("target")
    schedule = data.get("schedule") or {}

    if target and target.get("type") == "sql" and target.get("sql") == "SELECT id AS user_id FROM users":
        t_txt = "–í—Å–µ"
    else:
        t_txt = target.get("type", "‚Äî") if target else "‚Äî"

    when_txt = "—Å–µ–π—á–∞—Å (–ú–°–ö)"
    if schedule.get("mode") == "at" and schedule.get("at"):
        at: datetime = schedule["at"]
        when_txt = f"{at.strftime('%Y-%m-%d %H:%M %z')} (–ú–°–ö)"

    prev = await _audience_preview_text(target) if target else "‚Äî"

    text = (
        "–ü—Ä–æ–≤–µ—Ä—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ä–∞—Å—Å—ã–ª–∫–∏:\n"
        f"‚Ä¢ –ù–∞–∑–≤–∞–Ω–∏–µ: <b>{_html_escape(title)}</b>\n"
        f"‚Ä¢ –¢–∏–ø: <b>{kind}</b>\n"
        f"‚Ä¢ –ê—É–¥–∏—Ç–æ—Ä–∏—è: <b>{t_txt}</b>\n"
        f"‚Ä¢ –ö–æ–≥–¥–∞: <b>{when_txt}</b>\n"
        f"{prev}\n\n"
        "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å?"
    )

    if isinstance(evt, CallbackQuery):
        await evt.message.edit_text(text, reply_markup=_kb_confirm().as_markup())
    else:
        await evt.answer(text, reply_markup=_kb_confirm().as_markup())

@router.callback_query(F.data == "post:confirm")
async def post_confirm(cb: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    collected = data["collected"]
    title = data["title"]
    kind = data["kind"]
    target = data["target"]
    schedule = data["schedule"]

    # 1) —á–µ—Ä–Ω–æ–≤–∏–∫
    text_html = collected.get("text_html") or ""
    br = await db_api_client.create_broadcast(
        kind=kind,
        title=title,
        content_html=text_html,
    )

    # 2) –º–µ–¥–∏–∞
    items = _make_media_items(collected)
    if items:
        await db_api_client.put_broadcast_media(br["id"], items)

    # 3) —Ç–∞—Ä–≥–µ—Ç
    await db_api_client.put_broadcast_target(br["id"], target)

    # 4) —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ / –æ—Ç–ø—Ä–∞–≤–∫–∞
    if schedule["mode"] == "now":
        # –ú–≥–Ω–æ–≤–µ–Ω–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞: –±–µ–∑ –≤—ã—Å—Ç–∞–≤–ª–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏, —Å—Ä–∞–∑—É send_now (–±—ç–∫ —Å–∞–º –ø–æ—Å—Ç–∞–≤–∏—Ç –ú–°–ö)
        await db_api_client.send_broadcast_now(br["id"])
        await cb.message.edit_text(f"‚úÖ –°–æ–∑–¥–∞–Ω–æ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è: <b>#{br['id']}</b>")
    elif schedule["mode"] == "at":
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ú–°–ö –∫–∞–∫ NAIVE 'YYYY-MM-DD HH:MM:SS' –∏ —Å—Ç–∞–≤–∏–º –ª–æ–∫–∞–ª—å–Ω—É—é –∑–∞–¥–∞—á—É
        at: datetime = schedule["at"]  # aware (MSK)
        # –¥–µ–ª–∞–µ–º naive –ú–°–ö –¥–ª—è API
        msk_naive = at.astimezone(MSK).replace(tzinfo=None)
        iso_naive = msk_naive.strftime("%Y-%m-%d %H:%M:%S")
        await db_api_client.update_broadcast(br["id"], status="scheduled", scheduled_at=iso_naive)

        # –ú–≥–Ω–æ–≤–µ–Ω–Ω–æ –ø–ª–∞–Ω–∏—Ä—É–µ–º –ª–æ–∫–∞–ª—å–Ω–æ (–±–µ–∑ –æ–∂–∏–¥–∞–Ω–∏—è –≤–æ—Ä–∫–µ—Ä–∞)
        schedule_broadcast_send(br["id"], at)

        await cb.message.edit_text(f"üíæ –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ –∏ –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–æ –ª–æ–∫–∞–ª—å–Ω–æ: <b>#{br['id']}</b> –Ω–∞ {iso_naive} (–ú–°–ö)")
    else:
        await cb.message.edit_text(f"üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –∫–∞–∫ —á–µ—Ä–Ω–æ–≤–∏–∫: <b>#{br['id']}</b>")

    await state.clear()

# ---- —Å–±–æ—Ä –∫–æ–Ω—Ç–µ–Ω—Ç–∞ ----

@router.message(PostWizard.collecting, F.content_type == ContentType.TEXT)
async def on_text(msg: Message, state: FSMContext):
    data = await state.get_data()
    data["collected"]["text_html"] = _html_escape(msg.html_text or msg.text or "")
    await state.update_data(collected=data["collected"])
    await msg.answer("–¢–µ–∫—Å—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω. –î–æ–±–∞–≤—å –º–µ–¥–∏–∞ (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ) –∏–ª–∏ –∂–º–∏ /done")

@router.message(PostWizard.collecting, F.content_type.in_({ContentType.PHOTO, ContentType.VIDEO, ContentType.DOCUMENT}))
async def on_single_media(msg: Message, state: FSMContext):
    data = await state.get_data()
    caption_html = _html_escape(msg.html_caption or "") if msg.caption else None
    if msg.photo:
        it = {"type": "photo", "file_id": msg.photo[-1].file_id, "caption_html": caption_html}
    elif msg.video:
        it = {"type": "video", "file_id": msg.video.file_id, "caption_html": caption_html}
    else:
        it = {"type": "document", "file_id": msg.document.file_id, "caption_html": caption_html}
    data["collected"]["single_media"].append(it)
    await state.update_data(collected=data["collected"])
    await msg.answer("–ú–µ–¥–∏–∞ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –ï—â—ë —á—Ç–æ-—Ç–æ? –ò–ª–∏ /done")

@router.message(PostWizard.collecting, F.media_group_id)
async def on_album_piece(msg: Message, state: FSMContext):
    data = await state.get_data()
    if data["collected"]["album"] is None:
        data["collected"]["album"] = []
    caption_html = _html_escape(msg.html_caption or "") if msg.caption else None
    if msg.photo:
        data["collected"]["album"].append({"type": "photo", "file_id": msg.photo[-1].file_id, "caption_html": caption_html})
    elif msg.video:
        data["collected"]["album"].append({"type": "video", "file_id": msg.video.file_id, "caption_html": caption_html})
    elif msg.document:
        data["collected"]["album"].append({"type": "document", "file_id": msg.document.file_id, "caption_html": caption_html})
    await state.update_data(collected=data["collected"])
